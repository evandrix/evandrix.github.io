#include <bits/stdc++.h>

using namespace std;

int get_t_layer(int index);
float get_t_version(int index);
int get_t_bitrate(int index, float version, int layer);
int get_t_samplerate(int index, float version);

int main(int argc, char *argv[])
{
	char *infilename = new char[48];
	memset(infilename, '\0', 48);
	if(!argv[1])
	{
		printf("\nEnter the name of the infile: ");
		cin >> infilename;
	}
	else
	{
		memcpy(infilename, argv[1], strlen(argv[1]));
	}
	ifstream infile(infilename, ios::binary|ios::in|ios::ate);
	if(!infile.is_open())
	{
		printf("Could not open input file!\n");
		return -1;
	}
	unsigned long infile_size = 0;
	// Calculate infile size
	infile_size = (long) infile.tellg();
	infile.seekg(0, ios::beg);
	// Let's make a signpost to describe where the information tag begins.
	unsigned long tag_loc = infile_size - 128;
	//printf("\nSize of input file: %d", infile_size);
	//printf("\nSize of input file - info tag: %d", tag_loc);
	// Need a buffer or two...
	unsigned char buf1 = 0;
	unsigned char buf2 = 0;
	unsigned char buf3 = 0;
	unsigned char buf4 = 0;
	unsigned char buf5 = 0;
	unsigned char buf6 = 0;
	unsigned char buf7 = 0;
	unsigned char buf8 = 0;
	unsigned char buf9 = 0;
	unsigned char buf10 = 0;
	unsigned char buf11 = 0;
	unsigned char buf12 = 0;
	unsigned char buf13 = 0;
	unsigned char buf14 = 0;
	unsigned char buf15 = 0;
	unsigned char buf16 = 0;
	unsigned char buf17 = 0;
	unsigned char buf18 = 0;
	unsigned long last_header_start = 0;
	unsigned long last_header_end = 0;
	int number_blocks = 0;
	int i = 0;
	// while ( (i < atoi(argv[2])) && ((int) infile.tellg() < tag_loc )) {
	while((!infile.eof()) && ((int) infile.tellg() < infile_size))
	{
		// printf ("\n--------------------------------------------------\n----------------- Loc --> %d -----------------", (int) infile.tellg() ); // DEBUG LINE
		number_blocks++;
		// ----------------------------------------------
		// layout
		// ----------------------------------------------
		// 1 2 3 4 5 6 7 8 9 10 11 12 13 14
		// [---][---][---][---][---][---][---][---][---][---][---][---][---][---]
		// [------Header------][---CRC--]...
		//
		buf1 = buf2 = buf3 = buf4 = buf5 = buf6 = buf7 = buf8 = buf9 = 0;
		buf10 = buf11 = buf12 = buf13 = buf14 = buf15 = buf16 = buf17 = buf18 = 0;
		//printf("\nBufs: %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d", buf1, buf2, buf3, buf4, buf5, buf6, buf7, buf8, buf9, buf10, buf11, buf12, buf13, buf14, buf15, buf16, buf17, buf18);
		buf1 = infile.get();
		buf2 = infile.get();
		buf3 = infile.get();
		buf4 = infile.get();
		buf5 = infile.get();
		buf6 = infile.get();
		buf7 = infile.get();
		buf8 = infile.get();
		buf9 = infile.get();
		buf10 = infile.get();
		buf11 = infile.get();
		buf12 = infile.get();
		buf13 = infile.get();
		buf14 = infile.get();
		buf15 = infile.get();
		buf16 = infile.get();
		buf17 = infile.get();
		buf18 = infile.get();
		//printf("\nBufs: %d %d %d %d %d %d %d %d [%d %d] %d %d %d %d %d [%d %d %d]", buf1, buf2, buf3, buf4, buf5, buf6, buf7, buf8, buf9, buf10, buf11, buf12, buf13, buf14, buf15, buf16, buf17, buf18);
		//printf("\nBufs: %d %d %d %d %d %d %d %d %d", buf1, buf2, buf3, buf4, buf5, buf6, buf7, buf8, buf9);
		//printf("\nBufs: %d %d %d %d", buf1, buf2, buf3, buf4);
		// These are the header-derived descriptors; denoted by 'h_' ----------
		int h_mpeg_version = (buf2 & 24) >> 3;
		int h_layer_descript = (buf2 & 6) >> 1;
		int h_bitrate = (buf3 & 240) >> 4;
		int h_sampling_rate = (buf3 & 12) >> 2;
		int padding = (buf3 & 2) >> 1;
		int crc_bit = (buf2 & 1);
		// --------------------------------------------------------------------
		// Translate these into the actual numbers; denoted by 't_' -----
		int t_layer = get_t_layer(h_layer_descript);
		float t_mpeg_version = get_t_version(h_mpeg_version);
		int t_bitrate = get_t_bitrate(h_bitrate, t_mpeg_version, t_layer);
		int t_sampling_rate = get_t_samplerate(h_sampling_rate, t_mpeg_version);
		//---------------------------------------------------------------------
		// Frame description; pretty much for DEBUG at this point -------------
		//printf("\nFrame %d -- ", number_blocks);
		//printf("\nMPEG Version: %1.1f (%d)", t_mpeg_version, h_mpeg_version );
		//printf("\nLayer Descriptor: %d (%d)", t_layer, h_layer_descript );
		//printf("\nBitrate: %d (%d)", t_bitrate, h_bitrate );
		//printf("\nSampling Rate: %d (%d)",t_sampling_rate, h_sampling_rate );
		//printf("\nPadding Bit: %d", padding );
		//printf("\nCRC bit: %d", crc_bit);
		// --------------------------------------------------------------------
		// 7 8 9 10 11 12 13 14 15
		// 123456781234567812345678123456781234567812345678123456781234567812345678
		// [--r_s--][pad][sh][---mdb----][-------][------][--]|[-------------][--][
		//
		// 16 17 18 19 20 21 22 23 24
		// 123456781234567812345678123456781234567812345678123456781234567812345678
		// -]|||[---mdb----]
		// Get reservoir size -- * TO DO (maybe) this needs to be compensated for no CRC
		//int reservoir_size = (buf7 << 1) | ((buf8 & 128) >> 7);
		//printf("\nReservoir size: %d", reservoir_size);
		// Get the main data bits
		int mdb1 = 0, mdb2 = 0;
		// Check value of CRC bit to see where to get main data bits
		if(crc_bit == 1)
		{
			//printf("\nNo CRC protection...");
			mdb1 = (buf7 & 63) << 6;
			mdb1 = mdb1 | ((buf8 & 252) >> 2);
			mdb2 = (buf14 & 7) << 9;
			mdb2 = mdb2 | (buf15 << 1);
			mdb2 = mdb2 | ((buf16 & 128) >> 7);
		}
		else
		{
			//printf ("\nCRC protection found...");
			mdb1 = (buf9 & 63);
			mdb1 = mdb1 << 6;
			mdb1 = mdb1 | ((buf10 & 252) >> 2);
			mdb2 = (buf16 & 7) << 9;
			mdb2 = mdb2 | (buf17 << 1);
			mdb2 = mdb2 | ((buf18 & 128) >> 7);
		}
		printf("\t%d\t%d", mdb1, mdb2);
		int frame_length = (144 * t_bitrate * 1000 / t_sampling_rate) + padding;
		//printf("\nFrame Length: %d",frame_length );
		int offset = frame_length - 18;
		infile.seekg(offset, ios::cur);
		i++;
	}
	//printf("\n\nTotal frames found: %d", number_blocks);
	infile.close();
	delete[] infilename;
}

int get_t_layer(int index)
{
	switch(index)
	{
		case 0:
			return -1;
			break;
		case 1:
			return 3;
			break;
		case 2:
			return 2;
			break;
		case 3:
			return 1;
			break;
	}
}
float get_t_version(int index)
{
	switch(index)
	{
		case 0:
			return 2.5;
			break;
		case 1:
			return -1;
			break;
		case 2:
			return 2;
			break;
		case 3:
			return 1;
			break;
	}
}

int get_t_bitrate(int index, float version, int layer)
{
	if(version == 1)
	{
		switch(layer)
		{
			case 1:
				switch(index)
				{
					case 1:
						return 32;
						break;
					case 2:
						return 64;
						break;
					case 3:
						return 96;
						break;
					case 4:
						return 128;
						break;
					case 5:
						return 160;
						break;
					case 6:
						return 192;
						break;
					case 7:
						return 224;
						break;
					case 8:
						return 256;
						break;
					case 9:
						return 288;
						break;
					case 10:
						return 320;
						break;
					case 11:
						return 352;
						break;
					case 12:
						return 384;
						break;
					case 13:
						return 416;
						break;
					case 14:
						return 448;
						break;
					case 15:
						return -1;
						break;
				}
				break;
			case 2:
				switch(index)
				{
					case 1:
						return 32;
						break;
					case 2:
						return 48;
						break;
					case 3:
						return 56;
						break;
					case 4:
						return 64;
						break;
					case 5:
						return 80;
						break;
					case 6:
						return 96;
						break;
					case 7:
						return 112;
						break;
					case 8:
						return 128;
						break;
					case 9:
						return 160;
						break;
					case 10:
						return 192;
						break;
					case 11:
						return 224;
						break;
					case 12:
						return 256;
						break;
					case 13:
						return 320;
						break;
					case 14:
						return 384;
						break;
					case 15:
						return -1;
						break;
				}
				break;
			case 3:
				switch(index)
				{
					case 1:
						return 32;
						break;
					case 2:
						return 40;
						break;
					case 3:
						return 48;
						break;
					case 4:
						return 56;
						break;
					case 5:
						return 64;
						break;
					case 6:
						return 80;
						break;
					case 7:
						return 96;
						break;
					case 8:
						return 112;
						break;
					case 9:
						return 128;
						break;
					case 10:
						return 160;
						break;
					case 11:
						return 192;
						break;
					case 12:
						return 224;
						break;
					case 13:
						return 256;
						break;
					case 14:
						return 320;
						break;
					case 15:
						return -1;
						break;
				}
				break;
		}
	}
	else if(version >=2)
	{
		switch(layer)
		{
			case 1:
				switch(index)
				{
					case 1:
						return 32;
						break;
					case 2:
						return 48;
						break;
					case 3:
						return 56;
						break;
					case 4:
						return 64;
						break;
					case 5:
						return 80;
						break;
					case 6:
						return 96;
						break;
					case 7:
						return 112;
						break;
					case 8:
						return 128;
						break;
					case 9:
						return 144;
						break;
					case 10:
						return 160;
						break;
					case 11:
						return 176;
						break;
					case 12:
						return 192;
						break;
					case 13:
						return 224;
						break;
					case 14:
						return 256;
						break;
					case 15:
						return -1;
						break;
				}
				break;
			case 2:
				switch(index)
				{
					case 1:
						return 8;
						break;
					case 2:
						return 16;
						break;
					case 3:
						return 24;
						break;
					case 4:
						return 32;
						break;
					case 5:
						return 40;
						break;
					case 6:
						return 48;
						break;
					case 7:
						return 56;
						break;
					case 8:
						return 64;
						break;
					case 9:
						return 80;
						break;
					case 10:
						return 96;
						break;
					case 11:
						return 112;
						break;
					case 12:
						return 128;
						break;
					case 13:
						return 144;
						break;
					case 14:
						return 160;
						break;
					case 15:
						return -1;
						break;
				}
				break;
			case 3:
				switch(index)
				{
					case 1:
						return 8;
						break;
					case 2:
						return 16;
						break;
					case 3:
						return 24;
						break;
					case 4:
						return 32;
						break;
					case 5:
						return 40;
						break;
					case 6:
						return 48;
						break;
					case 7:
						return 56;
						break;
					case 8:
						return 64;
						break;
					case 9:
						return 80;
						break;
					case 10:
						return 96;
						break;
					case 11:
						return 112;
						break;
					case 12:
						return 128;
						break;
					case 13:
						return 144;
						break;
					case 14:
						return 160;
						break;
					case 15:
						return -1;
						break;
				}
				break;
		}
	}
}

int get_t_samplerate(int index, float version)
{
	if(version == 1)
	{
		switch(index)
		{
			case 0:
				return 44100;
				break;
			case 1:
				return 48000;
				break;
			case 2:
				return 32000;
				break;
			case 3:
				return -1;
				break;
		}
	}
	else if(version == 2)
	{
		switch(index)
		{
			case 0:
				return 22050;
				break;
			case 1:
				return 24000;
				break;
			case 2:
				return 16000;
				break;
			case 3:
				return -1;
				break;
		}
	}
	else if(version == 2.5)
	{
		switch(index)
		{
			case 0:
				return 11025;
				break;
			case 1:
				return 12000;
				break;
			case 2:
				return 8000;
				break;
			case 3:
				return -1;
				break;
		}
	}
}
